{"version":3,"sources":["../src/statistics.ts"],"names":["max","x","length","Error","value","i","min","sum","sumNum","correction","transition","Math","abs","mean","mode","sort","last","NaN","maxSeen","seenThis","statMap","getColumn","data","columnName","map","item","getSatByColumn","type","column"],"mappings":"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","sourcesContent":["interface IItemData {\n  [key: string]: any;\n}\nfunction max(x: number[]) {\n  if (x.length === 0) {\n    throw new Error('max requires at least one data point');\n  }\n\n  let value = x[0];\n  for (let i = 1; i < x.length; i++) {\n    // On the first iteration of this loop, max is\n    // undefined and is thus made the maximum element in the array\n    if (x[i] > value) {\n      value = x[i];\n    }\n  }\n  return value;\n}\n\nfunction min(x: number[]) {\n  if (x.length === 0) {\n    throw new Error('min requires at least one data point');\n  }\n\n  let value = x[0];\n  for (let i = 1; i < x.length; i++) {\n    // On the first iteration of this loop, min is\n    // undefined and is thus made the minimum element in the array\n    if (x[i] < value) {\n      value = x[i];\n    }\n  }\n  return value;\n}\n\nfunction sum(x: number[]) {\n  // If the array is empty, we needn't bother computing its sum\n  if (x.length === 0) {\n    return 0;\n  }\n\n  // Initializing the sum as the first number in the array\n  let sumNum = x[0] * 1;\n\n  // Keeping track of the floating-point error correction\n  let correction = 0;\n\n  let transition;\n\n  for (let i = 1; i < x.length; i++) {\n    transition = sumNum + x[i] * 1;\n\n    // Here we need to update the correction in a different fashion\n    // if the new absolute value is greater than the absolute sum\n    if (Math.abs(sumNum) >= Math.abs(x[i])) {\n      correction += sumNum - transition + x[i];\n    } else {\n      correction += x[i] - transition + sumNum;\n    }\n\n    sumNum = transition;\n  }\n\n  // Returning the corrected sum\n  return sumNum + correction * 1;\n}\nfunction mean(x: number[]) {\n  if (x.length === 0) {\n    throw new Error('mean requires at least one data point');\n  }\n  return sum(x) / x.length;\n}\n\nfunction mode(x: any[]) {\n  if (x.length === 0) {\n    throw new Error('mean requires at least one data point');\n  }\n  if (x.length < 3) {\n    return x[0];\n  }\n  x.sort();\n  let last = x[0];\n  let value = NaN;\n  let maxSeen = 0;\n  let seenThis = 1;\n\n  for (let i = 1; i < x.length + 1; i++) {\n    if (x[i] !== last) {\n      if (seenThis > maxSeen) {\n        maxSeen = seenThis;\n        value = last;\n      }\n      seenThis = 1;\n      last = x[i];\n    } else {\n      seenThis++;\n    }\n  }\n  return value;\n}\n\nexport { sum, max, min, mean, mode };\nexport const statMap: { [key: string]: any } = {\n  min,\n  max,\n  mean,\n  sum,\n  mode,\n};\nexport function getColumn(data: IItemData[], columnName: string) {\n  return data.map((item: IItemData) => {\n    return item[columnName];\n  });\n}\n\nexport function getSatByColumn(type: string, column: number[]) {\n  return statMap[type](column);\n}\n"],"file":"statistics.js"}