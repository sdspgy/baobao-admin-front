"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_RADIUS = exports.DEFAULT_CUTOFF = exports.DEFAULT_BUFFER = exports.DEFAULT_FONT_SIZE = exports.DEFAULT_FONT_WEIGHT = exports.DEFAULT_FONT_FAMILY = exports.DEFAULT_CHAR_SET = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _l7Utils = require("@antv/l7-utils");

var _tinySdf = _interopRequireDefault(require("@mapbox/tiny-sdf"));

var _inversify = require("inversify");

var _font_util = require("../../utils/font_util");

var _dec, _class, _temp;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_CHAR_SET = getDefaultCharacterSet();
exports.DEFAULT_CHAR_SET = DEFAULT_CHAR_SET;
var DEFAULT_FONT_FAMILY = 'sans-serif';
exports.DEFAULT_FONT_FAMILY = DEFAULT_FONT_FAMILY;
var DEFAULT_FONT_WEIGHT = 'normal';
exports.DEFAULT_FONT_WEIGHT = DEFAULT_FONT_WEIGHT;
var DEFAULT_FONT_SIZE = 24;
exports.DEFAULT_FONT_SIZE = DEFAULT_FONT_SIZE;
var DEFAULT_BUFFER = 3;
exports.DEFAULT_BUFFER = DEFAULT_BUFFER;
var DEFAULT_CUTOFF = 0.25;
exports.DEFAULT_CUTOFF = DEFAULT_CUTOFF;
var DEFAULT_RADIUS = 8;
exports.DEFAULT_RADIUS = DEFAULT_RADIUS;
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 1.0;
var HEIGHT_SCALE = 1.0;
var CACHE_LIMIT = 3;
var VALID_PROPS = ['fontFamily', 'fontWeight', 'characterSet', 'fontSize', 'sdf', 'buffer', 'cutoff', 'radius'];

function getDefaultCharacterSet() {
  var charSet = [];

  for (var i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }

  return charSet;
}

function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
  ctx.fillStyle = 'black';
  ctx.textBaseline = 'middle';
}

function populateAlphaChannel(alphaChannel, imageData) {
  for (var i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}

var FontService = (_dec = (0, _inversify.injectable)(), _dec(_class = (_temp = function () {
  function FontService() {
    (0, _classCallCheck2.default)(this, FontService);
    this.fontAtlas = void 0;
    this.iconFontGlyphs = {};
    this.fontOptions = void 0;
    this.key = void 0;
    this.cache = new _l7Utils.LRUCache(CACHE_LIMIT);
  }

  (0, _createClass2.default)(FontService, [{
    key: "init",
    value: function init() {
      this.cache.clear();
      this.fontOptions = {
        fontFamily: DEFAULT_FONT_FAMILY,
        fontWeight: DEFAULT_FONT_WEIGHT,
        characterSet: DEFAULT_CHAR_SET,
        fontSize: DEFAULT_FONT_SIZE,
        buffer: DEFAULT_BUFFER,
        sdf: true,
        cutoff: DEFAULT_CUTOFF,
        radius: DEFAULT_RADIUS
      };
      this.key = '';
    }
  }, {
    key: "addIconGlyphs",
    value: function addIconGlyphs(glyphs) {
      var _this = this;

      glyphs.forEach(function (glyph) {
        _this.iconFontGlyphs[glyph.name] = glyph.unicode;
      });
    }
  }, {
    key: "getGlyph",
    value: function getGlyph(name) {
      if (this.iconFontGlyphs[name]) {
        return String.fromCharCode(parseInt(this.iconFontGlyphs[name], 16));
      }

      return '';
    }
  }, {
    key: "setFontOptions",
    value: function setFontOptions(option) {
      this.fontOptions = _objectSpread({}, this.fontOptions, {}, option);
      this.key = this.getKey();
      var charSet = this.getNewChars(this.key, this.fontOptions.characterSet);
      var cachedFontAtlas = this.cache.get(this.key);

      if (cachedFontAtlas && charSet.length === 0) {
        return;
      }

      var fontAtlas = this.generateFontAtlas(this.key, charSet, cachedFontAtlas);
      this.fontAtlas = fontAtlas;
      this.cache.set(this.key, fontAtlas);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.cache.clear();
    }
  }, {
    key: "generateFontAtlas",
    value: function generateFontAtlas(key, characterSet, cachedFontAtlas) {
      var _this$fontOptions = this.fontOptions,
          fontFamily = _this$fontOptions.fontFamily,
          fontWeight = _this$fontOptions.fontWeight,
          fontSize = _this$fontOptions.fontSize,
          buffer = _this$fontOptions.buffer,
          sdf = _this$fontOptions.sdf,
          radius = _this$fontOptions.radius,
          cutoff = _this$fontOptions.cutoff;
      var canvas = cachedFontAtlas && cachedFontAtlas.data;

      if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.width = MAX_CANVAS_WIDTH;
      }

      var ctx = canvas.getContext('2d');
      setTextStyle(ctx, fontFamily, fontSize, fontWeight);

      var _buildMapping = (0, _font_util.buildMapping)(_objectSpread({
        getFontWidth: function getFontWidth(char) {
          return ctx.measureText(char).width;
        },
        fontHeight: fontSize * HEIGHT_SCALE,
        buffer: buffer,
        characterSet: characterSet,
        maxCanvasWidth: MAX_CANVAS_WIDTH
      }, cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      })),
          mapping = _buildMapping.mapping,
          canvasHeight = _buildMapping.canvasHeight,
          xOffset = _buildMapping.xOffset,
          yOffset = _buildMapping.yOffset;

      if (canvas.height !== canvasHeight) {
        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        canvas.height = canvasHeight;
        ctx.putImageData(imageData, 0, 0);
      }

      setTextStyle(ctx, fontFamily, fontSize, fontWeight);

      if (sdf) {
        var tinySDF = new _tinySdf.default(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);

        var _imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = characterSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var char = _step.value;
            populateAlphaChannel(tinySDF.draw(char), _imageData);
            ctx.putImageData(_imageData, mapping[char].x, mapping[char].y);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = characterSet[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _char = _step2.value;
            ctx.fillText(_char, mapping[_char].x, mapping[_char].y + fontSize * BASELINE_SCALE);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return {
        xOffset: xOffset,
        yOffset: yOffset,
        mapping: mapping,
        data: canvas,
        width: canvas.width,
        height: canvas.height
      };
    }
  }, {
    key: "getKey",
    value: function getKey() {
      var _this$fontOptions2 = this.fontOptions,
          fontFamily = _this$fontOptions2.fontFamily,
          fontWeight = _this$fontOptions2.fontWeight,
          fontSize = _this$fontOptions2.fontSize,
          buffer = _this$fontOptions2.buffer,
          sdf = _this$fontOptions2.sdf,
          radius = _this$fontOptions2.radius,
          cutoff = _this$fontOptions2.cutoff;

      if (sdf) {
        return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer, " ").concat(radius, " ").concat(cutoff);
      }

      return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer);
    }
  }, {
    key: "getNewChars",
    value: function getNewChars(key, characterSet) {
      var cachedFontAtlas = this.cache.get(key);

      if (!cachedFontAtlas) {
        return characterSet;
      }

      var newChars = [];
      var cachedMapping = cachedFontAtlas.mapping;
      var cachedCharSet = new Set(Object.keys(cachedMapping));
      var charSet = new Set(characterSet);
      charSet.forEach(function (char) {
        if (!cachedCharSet.has(char)) {
          newChars.push(char);
        }
      });
      return newChars;
    }
  }, {
    key: "scale",
    get: function get() {
      return HEIGHT_SCALE;
    }
  }, {
    key: "canvas",
    get: function get() {
      var data = this.cache.get(this.key);
      return data && data.data;
    }
  }, {
    key: "mapping",
    get: function get() {
      var data = this.cache.get(this.key);
      return data && data.mapping;
    }
  }]);
  return FontService;
}(), _temp)) || _class);
exports.default = FontService;
//# sourceMappingURL=FontService.js.map