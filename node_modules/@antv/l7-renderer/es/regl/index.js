import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";

var _dec, _class, _temp;

import { injectable } from 'inversify';
import regl from 'regl';
import ReglAttribute from './ReglAttribute';
import ReglBuffer from './ReglBuffer';
import ReglElements from './ReglElements';
import ReglFramebuffer from './ReglFramebuffer';
import ReglModel from './ReglModel';
import ReglTexture2D from './ReglTexture2D';
var ReglRendererService = (_dec = injectable(), _dec(_class = (_temp = function () {
  function ReglRendererService() {
    var _this = this;

    _classCallCheck(this, ReglRendererService);

    this.gl = void 0;
    this.$container = void 0;

    this.createModel = function (options) {
      return new ReglModel(_this.gl, options);
    };

    this.createAttribute = function (options) {
      return new ReglAttribute(_this.gl, options);
    };

    this.createBuffer = function (options) {
      return new ReglBuffer(_this.gl, options);
    };

    this.createElements = function (options) {
      return new ReglElements(_this.gl, options);
    };

    this.createTexture2D = function (options) {
      return new ReglTexture2D(_this.gl, options);
    };

    this.createFramebuffer = function (options) {
      return new ReglFramebuffer(_this.gl, options);
    };

    this.useFramebuffer = function (framebuffer, drawCommands) {
      _this.gl({
        framebuffer: framebuffer ? framebuffer.get() : null
      })(drawCommands);
    };

    this.clear = function (options) {
      var color = options.color,
          depth = options.depth,
          stencil = options.stencil,
          _options$framebuffer = options.framebuffer,
          framebuffer = _options$framebuffer === void 0 ? null : _options$framebuffer;
      var reglClearOptions = {
        color: color,
        depth: depth,
        stencil: stencil
      };
      reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();

      _this.gl.clear(reglClearOptions);
    };

    this.viewport = function (_ref) {
      var _this$$container;

      var x = _ref.x,
          y = _ref.y,
          width = _ref.width,
          height = _ref.height;
      var renderCanvas = (_this$$container = _this.$container) === null || _this$$container === void 0 ? void 0 : _this$$container.getElementsByTagName('canvas')[0];

      if (renderCanvas) {
        renderCanvas.width = width;
        renderCanvas.height = height;
        renderCanvas.style.width = width / 2 + 'px';
        renderCanvas.style.height = height / 2 + 'px';
      }

      _this.gl._gl.viewport(x, y, width, height);

      _this.gl._refresh();
    };

    this.readPixels = function (options) {
      var framebuffer = options.framebuffer,
          x = options.x,
          y = options.y,
          width = options.width,
          height = options.height;
      var readPixelsOptions = {
        x: x,
        y: y,
        width: width,
        height: height
      };

      if (framebuffer) {
        readPixelsOptions.framebuffer = framebuffer.get();
      }

      return _this.gl.read(readPixelsOptions);
    };

    this.getViewportSize = function () {
      return {
        width: _this.gl._gl.drawingBufferWidth,
        height: _this.gl._gl.drawingBufferHeight
      };
    };

    this.getContainer = function () {
      return _this.$container;
    };

    this.destroy = function () {
      _this.gl.destroy();
    };
  }

  _createClass(ReglRendererService, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(_regeneratorRuntime.mark(function _callee($container, cfg) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.$container = $container;
                _context.next = 3;
                return new Promise(function (resolve, reject) {
                  regl({
                    container: $container,
                    attributes: {
                      alpha: true,
                      antialias: cfg.antialias,
                      premultipliedAlpha: true,
                      preserveDrawingBuffer: cfg.preserveDrawingBuffer
                    },
                    extensions: ['OES_element_index_uint', 'OES_standard_derivatives', 'angle_instanced_arrays'],
                    optionalExtensions: ['oes_texture_float_linear', 'OES_texture_float', 'EXT_texture_filter_anisotropic', 'EXT_blend_minmax', 'WEBGL_depth_texture'],
                    profile: true,
                    onDone: function onDone(err, r) {
                      if (err || !r) {
                        reject(err);
                      }

                      resolve(r);
                    }
                  });
                });

              case 3:
                this.gl = _context.sent;

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init(_x, _x2) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }]);

  return ReglRendererService;
}(), _temp)) || _class);
export { ReglRendererService as default };
//# sourceMappingURL=index.js.map