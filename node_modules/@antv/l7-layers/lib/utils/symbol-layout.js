"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shapeText = shapeText;
exports.getGlyphQuads = getGlyphQuads;

function getAnchorAlignment(anchor) {
  var horizontalAlign = 0.5;
  var verticalAlign = 0.5;

  switch (anchor) {
    case 'right':
    case 'top-right':
    case 'bottom-right':
      horizontalAlign = 1;
      break;

    case 'left':
    case 'top-left':
    case 'bottom-left':
      horizontalAlign = 0;
      break;

    default:
      horizontalAlign = 0.5;
  }

  switch (anchor) {
    case 'bottom':
    case 'bottom-right':
    case 'bottom-left':
      verticalAlign = 1;
      break;

    case 'top':
    case 'top-right':
    case 'top-left':
      verticalAlign = 0;
      break;

    default:
      verticalAlign = 0.5;
  }

  return {
    horizontalAlign: horizontalAlign,
    verticalAlign: verticalAlign
  };
}

function justifyLine(positionedGlyphs, glyphMap, start, end, justify) {
  if (!justify) {
    return;
  }

  var lastPositionedGlyph = positionedGlyphs[end];
  var glyph = lastPositionedGlyph.glyph;

  if (glyph) {
    var lastAdvance = glyphMap[glyph].advance * lastPositionedGlyph.scale;
    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;

    for (var j = start; j <= end; j++) {
      positionedGlyphs[j].x -= lineIndent;
    }
  }
}

function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lineCount) {
  var shiftX = (justify - horizontalAlign) * maxLineLength;
  var shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = positionedGlyphs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var glyphs = _step.value;
      glyphs.x += shiftX;
      glyphs.y += shiftY;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function shapeLines(shaping, glyphMap, lines, lineHeight, textAnchor, textJustify, spacing) {
  var yOffset = -8;
  var x = 0;
  var y = yOffset;
  var maxLineLength = 0;
  var positionedGlyphs = shaping.positionedGlyphs;
  var justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;
  var lineStartIndex = positionedGlyphs.length;
  lines.forEach(function (line) {
    line.split('').forEach(function (char) {
      var glyph = glyphMap[char];
      var baselineOffset = 0;

      if (glyph) {
        positionedGlyphs.push({
          glyph: char,
          x: x,
          y: y + baselineOffset,
          vertical: false,
          scale: 1,
          metrics: glyph
        });
        x += glyph.advance + spacing;
      }
    });

    if (positionedGlyphs.length !== lineStartIndex) {
      var lineLength = x - spacing;
      maxLineLength = Math.max(lineLength, maxLineLength);
      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);
    }

    x = 0;
    y += lineHeight;
  });

  var _getAnchorAlignment = getAnchorAlignment(textAnchor),
      horizontalAlign = _getAnchorAlignment.horizontalAlign,
      verticalAlign = _getAnchorAlignment.verticalAlign;

  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);
  var height = y - yOffset;
  shaping.top += -verticalAlign * height;
  shaping.bottom = shaping.top + height;
  shaping.left += -horizontalAlign * maxLineLength;
  shaping.right = shaping.left + maxLineLength;
}

function shapeText(text, glyphs, lineHeight, textAnchor, textJustify, spacing) {
  var translate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [0, 0];
  var lines = text.split('\n');
  var positionedGlyphs = [];
  var shaping = {
    positionedGlyphs: positionedGlyphs,
    top: translate[1],
    bottom: translate[1],
    left: translate[0],
    right: translate[0],
    lineCount: lines.length,
    text: text
  };
  shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing);

  if (!positionedGlyphs.length) {
    return false;
  }

  return shaping;
}

function getGlyphQuads(shaping) {
  var textOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];
  var alongLine = arguments.length > 2 ? arguments[2] : undefined;
  var _shaping$positionedGl = shaping.positionedGlyphs,
      positionedGlyphs = _shaping$positionedGl === void 0 ? [] : _shaping$positionedGl;
  var quads = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = positionedGlyphs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var positionedGlyph = _step2.value;
      var rect = positionedGlyph.metrics;
      var rectBuffer = 4;
      var halfAdvance = rect.advance * positionedGlyph.scale / 2;
      var glyphOffset = alongLine ? [positionedGlyph.x + halfAdvance, positionedGlyph.y] : [0, 0];
      var builtInOffset = alongLine ? [0, 0] : [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];
      var x1 = (0 - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];
      var y1 = (0 - rectBuffer) * positionedGlyph.scale + builtInOffset[1];
      var x2 = x1 + rect.width * positionedGlyph.scale;
      var y2 = y1 + rect.height * positionedGlyph.scale;
      var tl = {
        x: x1,
        y: y1
      };
      var tr = {
        x: x2,
        y: y1
      };
      var bl = {
        x: x1,
        y: y2
      };
      var br = {
        x: x2,
        y: y2
      };
      quads.push({
        tl: tl,
        tr: tr,
        bl: bl,
        br: br,
        tex: rect,
        glyphOffset: glyphOffset
      });
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return quads;
}
//# sourceMappingURL=symbol-layout.js.map