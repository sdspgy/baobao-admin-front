import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { AttributeType, gl } from '@antv/l7-core';
import { boundsContains, padBounds, rgb2arr } from '@antv/l7-utils';
import BaseModel from '../../core/BaseModel';
import CollisionIndex from '../../utils/collision-index';
import { calculteCentroid } from '../../utils/geo';
import { getGlyphQuads, shapeText } from '../../utils/symbol-layout';
var textFrag = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 48.0\nuniform sampler2D u_sdf_map;\nuniform float u_gamma_scale : 0.5;\n// uniform float u_font_size : 24.0;\nuniform float u_opacity : 1.0;\nuniform float u_stroke_opacity: 1.0;\nuniform vec4 u_stroke : [0, 0, 0, 1];\nuniform float u_strokeWidth : 2.0;\nuniform float u_halo_blur : 0.5;\nuniform float u_DevicePixelRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying float v_fontScale;\n\n#pragma include \"picking\"\nvoid main() {\n  // get sdf from atlas\n  float dist = texture2D(u_sdf_map, v_uv).a;\n\n  // float fontScale = u_font_size / FONT_SIZE;\n\n  lowp float buff = (6.0 - u_strokeWidth / v_fontScale) / SDF_PX;\n  highp float gamma = (u_halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (v_fontScale * u_gamma_scale) / 1.0;\n\n  highp float gamma_scaled = gamma * v_gamma_scale;\n\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n  gl_FragColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), vec4(u_stroke.rgb, u_stroke.a * u_opacity), smoothstep(0., 0.5, 1. - dist));\n  gl_FragColor.a= gl_FragColor.a * alpha;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var textVert = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 24.0\nattribute vec3 a_Position;\nattribute vec2 a_tex;\nattribute vec2 a_textOffsets;\nattribute vec4 a_Color;\nattribute float a_Size;\n\nuniform vec2 u_sdf_map_size;\nuniform mat4 u_ModelMatrix;\n\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying vec4 v_color;\nvarying float v_fontScale;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  v_color = a_Color;\n  v_uv = a_tex / u_sdf_map_size;\n\n  // \u6587\u672C\u7F29\u653E\u6BD4\u4F8B\n  float fontScale = a_Size / FONT_SIZE;\n   v_fontScale = fontScale;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n  vec4 projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  gl_Position = vec4(projected_position.xy / projected_position.w\n    + a_textOffsets * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n  v_gamma_scale = gl_Position.w;\n  setPickingColor(a_PickingColor);\n\n}\n";
export function TextTriangulation(feature) {
  var that = this;
  var id = feature.id;
  var vertices = [];
  var indices = [];

  if (!that.glyphInfoMap || !that.glyphInfoMap[id]) {
    return {
      vertices: [],
      indices: [],
      size: 7
    };
  }

  var centroid = that.glyphInfoMap[id].centroid;
  var coord = centroid.length === 2 ? [centroid[0], centroid[1], 0] : centroid;
  that.glyphInfoMap[id].glyphQuads.forEach(function (quad, index) {
    vertices.push.apply(vertices, _toConsumableArray(coord).concat([quad.tex.x, quad.tex.y + quad.tex.height, quad.tl.x, quad.tl.y], _toConsumableArray(coord), [quad.tex.x + quad.tex.width, quad.tex.y + quad.tex.height, quad.tr.x, quad.tr.y], _toConsumableArray(coord), [quad.tex.x + quad.tex.width, quad.tex.y, quad.br.x, quad.br.y], _toConsumableArray(coord), [quad.tex.x, quad.tex.y, quad.bl.x, quad.bl.y]));
    indices.push(0 + index * 4, 1 + index * 4, 2 + index * 4, 2 + index * 4, 3 + index * 4, 0 + index * 4);
  });
  return {
    vertices: vertices,
    indices: indices,
    size: 7
  };
}

var TextModel = function (_BaseModel) {
  _inherits(TextModel, _BaseModel);

  function TextModel() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, TextModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TextModel)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _this.glyphInfo = void 0;
    _this.glyphInfoMap = {};
    _this.texture = void 0;
    _this.currentZoom = -1;
    _this.extent = void 0;
    _this.textureHeight = 0;
    _this.textCount = 0;
    _this.preTextStyle = {};
    return _this;
  }

  _createClass(TextModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1.0 : _ref$opacity,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? '#fff' : _ref$stroke,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 0 : _ref$strokeWidth,
          _ref$strokeOpacity = _ref.strokeOpacity,
          strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,
          _ref$textAnchor = _ref.textAnchor,
          textAnchor = _ref$textAnchor === void 0 ? 'center' : _ref$textAnchor,
          _ref$textAllowOverlap = _ref.textAllowOverlap,
          textAllowOverlap = _ref$textAllowOverlap === void 0 ? false : _ref$textAllowOverlap,
          _ref$halo = _ref.halo,
          halo = _ref$halo === void 0 ? 0.5 : _ref$halo,
          _ref$gamma = _ref.gamma,
          gamma = _ref$gamma === void 0 ? 2.0 : _ref$gamma;

      var _this$fontService = this.fontService,
          canvas = _this$fontService.canvas,
          mapping = _this$fontService.mapping;

      if (Object.keys(mapping).length !== this.textCount) {
        this.updateTexture();
        this.textCount = Object.keys(mapping).length;
      }

      this.preTextStyle = {
        textAnchor: textAnchor,
        textAllowOverlap: textAllowOverlap
      };
      return {
        u_opacity: opacity,
        u_stroke_opacity: strokeOpacity,
        u_sdf_map: this.texture,
        u_stroke: rgb2arr(stroke),
        u_halo_blur: halo,
        u_gamma_scale: gamma,
        u_sdf_map_size: [canvas.width, canvas.height],
        u_strokeWidth: strokeWidth
      };
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _this2 = this;

      this.layer.on('remapping', function () {
        _this2.initGlyph();

        _this2.updateTexture();

        _this2.reBuildModel();
      });
      this.extent = this.textExtent();

      var _ref2 = this.layer.getLayerConfig(),
          _ref2$textAnchor = _ref2.textAnchor,
          textAnchor = _ref2$textAnchor === void 0 ? 'center' : _ref2$textAnchor,
          _ref2$textAllowOverla = _ref2.textAllowOverlap,
          textAllowOverlap = _ref2$textAllowOverla === void 0 ? true : _ref2$textAllowOverla;

      this.preTextStyle = {
        textAnchor: textAnchor,
        textAllowOverlap: textAllowOverlap
      };
      this.initGlyph();
      this.updateTexture();
      this.filterGlyphs();
      return [this.layer.buildLayerModel({
        moduleName: 'pointText',
        vertexShader: textVert,
        fragmentShader: textFrag,
        triangulation: TextTriangulation.bind(this),
        depth: {
          enable: false
        },
        blend: this.getBlend()
      })];
    }
  }, {
    key: "needUpdate",
    value: function needUpdate() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$textAllowOverla = _ref3.textAllowOverlap,
          textAllowOverlap = _ref3$textAllowOverla === void 0 ? false : _ref3$textAllowOverla;

      var zoom = this.mapService.getZoom();
      var extent = this.mapService.getBounds();
      var flag = boundsContains(this.extent, extent);

      if (!textAllowOverlap && (Math.abs(this.currentZoom - zoom) > 1 || !flag) || textAllowOverlap !== this.preTextStyle.textAllowOverlap) {
        this.reBuildModel();
        return true;
      }

      return false;
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'textOffsets',
        type: AttributeType.Attribute,
        descriptor: {
          name: 'a_textOffsets',
          buffer: {
            usage: gl.STATIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[5], vertex[6]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: gl.DYNAMIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 12 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'textUv',
        type: AttributeType.Attribute,
        descriptor: {
          name: 'a_tex',
          buffer: {
            usage: gl.DYNAMIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }, {
    key: "textExtent",
    value: function textExtent() {
      var bounds = this.mapService.getBounds();
      return padBounds(bounds, 0.5);
    }
  }, {
    key: "initTextFont",
    value: function initTextFont() {
      var _ref4 = this.layer.getLayerConfig(),
          _ref4$fontWeight = _ref4.fontWeight,
          fontWeight = _ref4$fontWeight === void 0 ? '800' : _ref4$fontWeight,
          _ref4$fontFamily = _ref4.fontFamily,
          fontFamily = _ref4$fontFamily === void 0 ? 'sans-serif' : _ref4$fontFamily;

      var data = this.layer.getEncodedData();
      var characterSet = [];
      data.forEach(function (item) {
        var _item$shape = item.shape,
            shape = _item$shape === void 0 ? '' : _item$shape;
        shape = shape.toString();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = shape[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var char = _step.value;

            if (characterSet.indexOf(char) === -1) {
              characterSet.push(char);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      });
      this.fontService.setFontOptions({
        characterSet: characterSet,
        fontWeight: fontWeight,
        fontFamily: fontFamily
      });
    }
  }, {
    key: "generateGlyphLayout",
    value: function generateGlyphLayout() {
      var _this3 = this;

      var mapping = this.fontService.mapping;

      var _ref5 = this.layer.getLayerConfig(),
          _ref5$spacing = _ref5.spacing,
          spacing = _ref5$spacing === void 0 ? 2 : _ref5$spacing,
          _ref5$textAnchor = _ref5.textAnchor,
          textAnchor = _ref5$textAnchor === void 0 ? 'center' : _ref5$textAnchor,
          textOffset = _ref5.textOffset;

      var data = this.layer.getEncodedData();
      this.glyphInfo = data.map(function (feature) {
        var _feature$shape = feature.shape,
            shape = _feature$shape === void 0 ? '' : _feature$shape,
            coordinates = feature.coordinates,
            id = feature.id,
            _feature$size2 = feature.size,
            size = _feature$size2 === void 0 ? 1 : _feature$size2;
        var shaping = shapeText(shape.toString(), mapping, size, textAnchor, 'center', spacing, textOffset);
        var glyphQuads = getGlyphQuads(shaping, textOffset, false);
        feature.shaping = shaping;
        feature.glyphQuads = glyphQuads;
        feature.centroid = calculteCentroid(coordinates);
        _this3.glyphInfoMap[id] = {
          shaping: shaping,
          glyphQuads: glyphQuads,
          centroid: calculteCentroid(coordinates)
        };
        return feature;
      });
    }
  }, {
    key: "filterGlyphs",
    value: function filterGlyphs() {
      var _this4 = this;

      var _ref6 = this.layer.getLayerConfig(),
          _ref6$padding = _ref6.padding,
          padding = _ref6$padding === void 0 ? [4, 4] : _ref6$padding,
          _ref6$textAllowOverla = _ref6.textAllowOverlap,
          textAllowOverlap = _ref6$textAllowOverla === void 0 ? false : _ref6$textAllowOverla;

      if (textAllowOverlap) {
        return;
      }

      this.glyphInfoMap = {};
      this.currentZoom = this.mapService.getZoom();
      this.extent = this.textExtent();

      var _this$rendererService = this.rendererService.getViewportSize(),
          width = _this$rendererService.width,
          height = _this$rendererService.height;

      var collisionIndex = new CollisionIndex(width, height);
      var filterData = this.glyphInfo.filter(function (feature) {
        var shaping = feature.shaping,
            _feature$id = feature.id,
            id = _feature$id === void 0 ? 0 : _feature$id;
        var centroid = feature.centroid;
        var size = feature.size;
        var fontScale = size / 24;

        var pixels = _this4.mapService.lngLatToContainer(centroid);

        var _collisionIndex$place = collisionIndex.placeCollisionBox({
          x1: shaping.left * fontScale - padding[0],
          x2: shaping.right * fontScale + padding[0],
          y1: shaping.top * fontScale - padding[1],
          y2: shaping.bottom * fontScale + padding[1],
          anchorPointX: pixels.x,
          anchorPointY: pixels.y
        }),
            box = _collisionIndex$place.box;

        if (box && box.length) {
          collisionIndex.insertCollisionBox(box, id);
          return true;
        } else {
          return false;
        }
      });
      filterData.forEach(function (item) {
        _this4.glyphInfoMap[item.id] = item;
      });
    }
  }, {
    key: "initGlyph",
    value: function initGlyph() {
      this.initTextFont();
      this.generateGlyphLayout();
    }
  }, {
    key: "updateTexture",
    value: function updateTexture() {
      var createTexture2D = this.rendererService.createTexture2D;
      var canvas = this.fontService.canvas;
      this.textureHeight = canvas.height;
      this.texture = createTexture2D({
        data: canvas,
        mag: gl.LINEAR,
        min: gl.LINEAR,
        width: canvas.width,
        height: canvas.height
      });
    }
  }, {
    key: "reBuildModel",
    value: function reBuildModel() {
      this.filterGlyphs();
      this.layer.models = [this.layer.buildLayerModel({
        moduleName: 'pointText',
        vertexShader: textVert,
        fragmentShader: textFrag,
        triangulation: TextTriangulation.bind(this),
        depth: {
          enable: false
        },
        blend: this.getBlend()
      })];
    }
  }]);

  return TextModel;
}(BaseModel);

export { TextModel as default };
//# sourceMappingURL=text.js.map